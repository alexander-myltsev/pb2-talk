<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>parboiled2</h1>
					<!-- <h3>A macro-based PEG parser generator for Scala 2.10+</h3> -->
					<h4>генерируемые макросами генераторы PEG-парсеров</h4>
					<p>
						<small><a href="https://github.com/alexander-myltsev">Александр Мыльцев</a> / <a href="http://twitter.com/alex_myltsev">@alex_myltsev</a></small>
					</p>
				</section>


				<section>
					<h2>задача парсинга</h2>
					<ul>
						<li>вход: строка, поток байт, ...</li>
						<li>выход: обладает структурой (да/нет), структура</li>
						<li>пример</li>
					</ul>

					<br/><br/>

					<pre style="width: 60%"><code data-trim class="scala">
1 + 2 * 3 — арифметическое выражение: да или нет?
					</code></pre>

					<pre style="width: 60%"><code data-trim class="scala">
1 + 2 * 3 ~> Plus(1, Mul(2, 3))
					</code></pre>
				</section>

				<section>
					<h2>регулярные выражения</h2>
					
					<p>нельзя: рекурсивные структуры</p>
					<ol>
						<li>калькулятор</li>
						<li>json</li>
						<li>...</li>
					</ol>

					<!-- <pre style="width: 50%"><code data-trim>
a*b = { b, ab, aab, aaab, ... }
					</code></pre>

					<img style="margin: 0 30px 30px 0; width: 10%" src="assets/ab_nda.svg"> -->
				</section>

				<section>
					<h2>рекурсивный нисходящий парсер: C/C++</h2>

					<pre><code data-trim class="cpp">
static int lex_scan_number(lex_t *lex, int c, json_error_t *error)
{
    const char *saved_text;
    char *end;
    double doubleval;

    lex->token = TOKEN_INVALID;

    if(c == '-')
        c = lex_get_save(lex, error);

    if(c == '0') {
        c = lex_get_save(lex, error);
        if(l_isdigit(c)) {
            lex_unget_unsave(lex, c);
            goto out;
        }
    }
    else if(l_isdigit(c)) {
        c = lex_get_save(lex, error);
        while(l_isdigit(c))
            c = lex_get_save(lex, error);
    }
    else {
        lex_unget_unsave(lex, c);
        goto out;
    }

    if(c != '.' && c != 'E' && c != 'e') {
        json_int_t intval;

        lex_unget_unsave(lex, c);

        saved_text = strbuffer_value(&lex->saved_text);

        errno = 0;
        intval = json_strtoint(saved_text, &end, 10);
        if(errno == ERANGE) {
            if(intval < 0)
                error_set(error, lex, "too big negative integer");
            else
                error_set(error, lex, "too big integer");
            goto out;
        }

        assert(end == saved_text + lex->saved_text.length);

        lex->token = TOKEN_INTEGER;
        lex->value.integer = intval;
        return 0;
    }

    if(c == '.') {
        c = lex_get(lex, error);
        if(!l_isdigit(c)) {
            lex_unget(lex, c);
            goto out;
        }
        lex_save(lex, c);

        c = lex_get_save(lex, error);
        while(l_isdigit(c))
            c = lex_get_save(lex, error);
    }

    if(c == 'E' || c == 'e') {
        c = lex_get_save(lex, error);
        if(c == '+' || c == '-')
            c = lex_get_save(lex, error);

        if(!l_isdigit(c)) {
            lex_unget_unsave(lex, c);
            goto out;
        }

        c = lex_get_save(lex, error);
        while(l_isdigit(c))
            c = lex_get_save(lex, error);
    }

    lex_unget_unsave(lex, c);

    if(jsonp_strtod(&lex->saved_text, &doubleval)) {
        error_set(error, lex, "real number overflow");
        goto out;
    }

    lex->token = TOKEN_REAL;
    lex->value.real = doubleval;
    return 0;

out:
    return -1;
}
					</code></pre>

					<a href="https://github.com/akheron/jansson/blob/master/src/load.c">https://github.com/akheron/jansson/blob/master/src/load.c</a>
				</section>

				<section>
					<h2>рекурсивный нисходящий парсер: JavaScript</h2>

					<pre><code data-trim>
        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },
					</code></pre>

					<a href="https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js">https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js</a>
				</section>

				<section>
					<h2>ANTLR3</h2>

					язык и среда разработки
					<pre style="width: 40%"><code data-trim>
grammar SimpleCalc;
 
add : NUMBER PLUS NUMBER;
 
NUMBER  : ('0'..'9')+ ;
 
PLUS    : '+';
					</code></pre>

					<br/>

					генерация java-файлов
					<pre style="width: 40%"><code data-trim>
					java org.antlr.Tool SimpleCalc.g
					</code></pre>

					<br/>

					подключение файлов к проекту
				</section>

				<section>
					<h2>комбинаторы парсеров</h2>
					<ul>
						<li>Haskell Parsec</li>
						<li>Scala Combinator Parsers</li>
						<li>FParsec</li>
					</ul>
				</section>

				<section>
					<h2>комбинаторы парсеров</h2>
					<h3>плюсы</h3>
					<ol style="width: 60%">
						<li>программа на исходном языке</li>
						<li>файлы в исходном проекте</li>
						<li>исходная среда разработки</li>
						<li>близкая к БНФ форма записи</li>
					</ol>

					<pre style="width: 80%"><code data-trim class="scala">
def expr    = term ~ rep("+" ~ term | "-" ~ term)
def term    = factor ~ rep("*" ~ factor | "/" ~ factor)
def factor  = floatingPointNumber | "(" ~ expr ~ ")"
					</code></pre>

					<br/>
					<h3>минусы</h3>
					<ol style="width: 60%">
						<li>интерпретатор</li>
						<li>временные объекты</li>
						<li>низкая скорость</li>
					</ol>
				</section>

				<section>
					<h2>parboiled2</h2>
					<ul>
						<li>PEG — грамматика, разбирающая выражение</li>
						<li>DSL — предметно-ориентированный язык</li>
						<li>типизация</li>
						<li>компиляция правил</li>
					</ul>
				</section>

				<section>
					<h2>parboiled2: DSL</h2>
					<ul>
						<li>rule { }</li>
						<li>ch, str</li>
						<li>a ~ b, a | b</li>
						<li>...</li>
					</ul>
				</section>

				<section>
					<h2>ABC-парсер</h2>
					<pre><code data-trim>
{ a^n b^n c^n: n >= 1 } = { abc, aabbcc, aaabbbccc, ... }
					</code></pre>

					<pre><code data-trim>
S ← &(A 'c') 'a'+ B !('a'/'b'/'c')
A ← 'a' A? 'b'
B ← 'b' B? 'c'
					</code></pre>

					<pre><code data-trim class="scala">
class ABCParser(val input: ParserInput) extends Parser {
  def S         = rule { &(A ~ 'c') ~ oneOrMore('a') ~ B ~ !(ch('a') | 'b' | 'c') ~ EOI }
  def A: Rule0  = rule { 'a' ~ optional(A) ~ 'b' }
  def B: Rule0  = rule { 'b' ~ optional(B) ~ 'c' }
}
					</code></pre>
				</section>

				<section>
					<h2>калькулятор</h2>
					<h2>JSON-парсер</h2>
				</section>

				<section>
					<h2>компиляция</h2>
					<pre><code data-trim class="scala">
abstract class Parser {
  def rule(r: Rule): Rule = macro ruleImpl
}

def ruleImpl(ctx: ParserContext)(r: ctx.Expr[Rule]): ctx.Expr[Rule] = r.tree match {
  case q"$a.this.str($s)" =>
  case q"$a.this.ch($ch)" =>
  case q"$lhs.|($rhs)"    =>
  case q"$lhs.~($rhs)"    =>
}
					</code></pre>
				</section>

				<section>
					<h2>char</h2>
					<pre><code data-trim class="scala">
case q"$a.this.ch($ch)" => reify {
  if ($ch == p.cursorChar()) {
    p.advance()
    Rule.MATCH
  } else Rule.MISMATCH
}
					</code></pre>
				</section>

				<section>
					<h2>string</h2>
					<pre><code data-trim class="scala">
case q"$a.this.str($s)" => reify {
  var ix = 0
  while (ix < $s.length && $s.charAt(ix) == p.cursorChar()) {
    ix += 1
    p.advance()
  }
  Rule(ix == $s.length)
}
					</code></pre>
				</section>

				<section>
					<h2>a | b</h2>
					<pre><code data-trim class="scala">
case q"$lhs.|($rhs)" => reify {
  val mark = p._cursor
  if (${render(lhs)}.matched) {
    Rule.MATCH
  } else {
    p._cursor = mark
    ${render(rhs)}
  }
}
					</code></pre>
				</section>

				<section>
					<h2>a ~ b</h2>
					<pre><code data-trim class="scala">
case q"$lhs.~($rhs)" => reify {
  Rule(${render(lhs)}.matched && ${render(rhs)}.matched)
}
					</code></pre>
				</section>

				<section>
					<h2>типизация правил и value-stack</h2>
					<pre style="width: 50%"><code data-trim class="scala">
class Rule[-I <: HList, +O <: HList]
I - тип значения со стека
O - тип значения в стек
					</code></pre>

					<pre style="width: 100%"><code data-trim class="scala">
def a:   Rule[     _, String] = rule { capture("a") }
def b:   Rule[     _, String] = rule { capture("7") }
def bi:  Rule[String, Int   ] = rule { b ~> ((_:String).toInt) }
def bd:  Rule[     _, Int   ] = rule { b ~> ((_:String).toDouble) } // compile error
					</code></pre>

					<pre style="width: 100%"><code data-trim class="scala">
def c1: Rule[     _, String::Int]         = rule { a ~ bi }
def c2: Rule[     _, String::String::Int] = rule { a ~ a ~> push(42) }

def c3: Rule[Int, Int] = rule { capture("7") ~> ((x: Int, y: String) => x + y.toInt) }
					</code></pre>
				</section>


				<section>
					<h1>конец</h1>
					<h3>вопросы?</h3>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
