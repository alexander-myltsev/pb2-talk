<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>parboiled2</h1>
					<!-- <h3>A macro-based PEG parser generator for Scala 2.10+</h3> -->
					<h4>генерируемые макросами генераторы PEG-парсеров</h4>
					<p>
						<small>
                            Александр Мыльцев /
                            <a href="https://github.com/alexander-myltsev">github</a> /
						    <a href="http://www.linkedin.com/in/alexandermyltsev">linkedin.com/in/alexandermyltsev</a>
                            <br/>
                            <a href="http://www.slideshare.net/AlexanderMyltsev/parboiled2-myltsev">презентация</a>
                        </small>
					</p>
				</section>


				<section>
					<h2>задача парсинга</h2>
					<ul>
						<li>вход: строка, поток байт, ...</li>
						<li>выход: обладает структурой (да/нет), структура</li>
						<li>пример</li>
					</ul>

					<br/><br/>

					<pre style="width: 60%"><code data-trim class="scala">
1 + 2 * 3 — арифметическое выражение: да или нет? — да
					</code></pre>

					<pre style="width: 60%"><code data-trim class="scala">
1 + 2 * 3 — структура? — Plus(1, Mul(2, 3))
					</code></pre>
				</section>

				<section>
					<h2>регулярные выражения</h2>
					
					<p>нельзя: рекурсивные структуры</p>
					<ol>
						<li>калькулятор</li>
						<li>json</li>
						<li>...</li>
					</ol>
				</section>

				<section>
					<h2>рекурсивный нисходящий парсер: C/C++</h2>

					<pre><code data-trim class="cpp">
static int lex_scan_number(lex_t *lex, int c, json_error_t *error)
{
    const char *saved_text;
    char *end;
    double doubleval;

    lex->token = TOKEN_INVALID;

    if(c == '-')
        c = lex_get_save(lex, error);

    if(c == '0') {
        c = lex_get_save(lex, error);
        if(l_isdigit(c)) {
            lex_unget_unsave(lex, c);
            goto out;
        }
    }
    else if(l_isdigit(c)) {
        c = lex_get_save(lex, error);
        while(l_isdigit(c))
            c = lex_get_save(lex, error);
    }
    else {
        lex_unget_unsave(lex, c);
        goto out;
    }

    if(c != '.' && c != 'E' && c != 'e') {
        json_int_t intval;

        lex_unget_unsave(lex, c);

        saved_text = strbuffer_value(&lex->saved_text);

        errno = 0;
        intval = json_strtoint(saved_text, &end, 10);
        if(errno == ERANGE) {
            if(intval < 0)
                error_set(error, lex, "too big negative integer");
            else
                error_set(error, lex, "too big integer");
            goto out;
        }

        assert(end == saved_text + lex->saved_text.length);

        lex->token = TOKEN_INTEGER;
        lex->value.integer = intval;
        return 0;
    }

    if(c == '.') {
        c = lex_get(lex, error);
        if(!l_isdigit(c)) {
            lex_unget(lex, c);
            goto out;
        }
        lex_save(lex, c);

        c = lex_get_save(lex, error);
        while(l_isdigit(c))
            c = lex_get_save(lex, error);
    }

    if(c == 'E' || c == 'e') {
        c = lex_get_save(lex, error);
        if(c == '+' || c == '-')
            c = lex_get_save(lex, error);

        if(!l_isdigit(c)) {
            lex_unget_unsave(lex, c);
            goto out;
        }

        c = lex_get_save(lex, error);
        while(l_isdigit(c))
            c = lex_get_save(lex, error);
    }

    lex_unget_unsave(lex, c);

    if(jsonp_strtod(&lex->saved_text, &doubleval)) {
        error_set(error, lex, "real number overflow");
        goto out;
    }

    lex->token = TOKEN_REAL;
    lex->value.real = doubleval;
    return 0;

out:
    return -1;
}
					</code></pre>

					<a href="https://github.com/akheron/jansson/blob/master/src/load.c">https://github.com/akheron/jansson/blob/master/src/load.c</a>
				</section>

				<section>
					<h2>рекурсивный нисходящий парсер: JavaScript</h2>

					<pre><code data-trim>
        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },
					</code></pre>

					<a href="https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js">https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js</a>
				</section>

				<section>
					<h2>рекурсивный нисходящий парсер</h2>
					<h3>плюсы</h3>
					<ol>
						<li>код на одном языке</li>
						<li>одна среда разработки</li>
						<li>высокая производительность</li>
					</ol>

					<br/><br/>

					<h3>минусы</h3>
					<ol>
						<li>нет предметно-ориентиррованного языка</li>
						<li>низкоуровневое кодирование</li>
					</ol>
				</section>

				<section>
					<h2>ANTLR3</h2>

					внутренний язык и среда разработки
					<pre style="width: 40%"><code data-trim>
grammar SimpleCalc;
 
add : NUMBER PLUS NUMBER;
 
NUMBER  : ('0'..'9')+ ;
 
PLUS    : '+';
					</code></pre>

					<br/>

					генерация java-файлов
					<pre style="width: 40%"><code data-trim>
					java org.antlr.Tool SimpleCalc.g
					</code></pre>

					<br/>

					подключение файлов к проекту
				</section>

				<section>
					<h2>ANTLR3</h2>
					<h3>плюсы</h3>
					<ol>
						<li>предметно-ориентированный язык</li>
						<li>высокая производительность</li>
					</ol>

					<br/><br/>

					<h3>минусы</h3>
					<ol>
						<li>новый язык, другая среда</li>
						<li>генерация и подключение файлов</li>
					</ol>
				</section>

				<section>
					<h2>комбинаторы парсеров</h2>
					<ul>
						<li>Haskell Parsec</li>
						<li>Scala Combinator Parsers</li>
						<li>FParsec</li>
					</ul>
				</section>

				<section>
					<h2>комбинаторы парсеров</h2>
					<h3>плюсы</h3>
					<ol style="width: 60%">
						<li>программа на исходном языке</li>
						<li>файлы в исходном проекте</li>
						<li>исходная среда разработки</li>
						<li>типизация парсеров</li>
						<li>близкая к БНФ форма записи</li>
					</ol>

					<pre style="width: 100%"><code data-trim class="scala">
//  Expr  ::= Term      { '+'   Term  | '-'   Term }
def expr    = term ~ rep( "+" ~ term  | "-" ~ term )

//  Term  ::=  Factor       { '*'   Factor | '/'   Factor }
def term    =  factor ~ rep ( "*" ~ factor | "/" ~ factor )

//  Factor  ::= Number | '('   Expr   ')'
def factor    = number | "(" ~ expr ~ ")"
					</code></pre>

					<br/>
					<h3>минусы</h3>
					<ol style="width: 60%">
						<li>интерпретатор</li>
						<li>временные объекты</li>
						<li>низкая производительность</li>
					</ol>
				</section>

				<section>
					<h2>генератор парсеров</h2>
					<ol>
						<li>на одном языке в одной среде разработки</li>
						<li>типизированный DSL</li>
						<li>компиляция, а не интерпритация</li>
					</ol>
				</section>

				<section>
					<h2>parboiled2</h2>
					<ul>
						<li>PEG — грамматика, разбирающая выражение</li>
						<li>типизированный DSL</li>
						<li>компиляция правил</li>
					</ul>
				</section>

				<section>
					<h2>rule, ch, str</h2>
					<ul>
						<li>реализация класса `Parser`</li>
						<li>правила грамматики внутри метода rule { }</li>
					</ul>

					<pre><code data-trim>
class SampleParser(val input: ParserInput) extends Parser {
  def Abc = rule { "abc" }
  def Ch  = rule { '7' }
  def Num = rule { 42 } // ошибка компиляции
}
					</code></pre>
				</section>

				<section>
					<h2>a ~ b, a | b</h2>
					<pre><code data-trim class="scala">
class SampleParser(val input: ParserInput) extends Parser {
  def r1 = rule { "a" ~ "b" } // "ab"
  def r2 = rule { "a" | "b" } // { "a", "b" }
  def r3 = rule { "a" ~ ("b" | "c") } // { "ab", "ac" }
  def r4 = rule { "ab" | "a" }
}
					</code></pre>
				</section>

				<section>
					<h2>zeroOrMore, oneOrMore</h2>
					<pre><code data-trim class="scala">
class SampleParser(val input: ParserInput) extends Parser {
  def r1 = rule { zeroOrMore("a") } // { "", "a", "aa", "aaa", ... }
  def r2 = rule { oneOrMore("a") }  // { "a", "aa", "aaa", ... }
}
					</code></pre>
				</section>

				<section>
					<h2>парсер арифметических выражений</h2>

					<pre><code data-trim class="scala">
class CalculatorParser(val input: ParserInput) extends Parser {
  def InputLine = rule { Expression ~ EOI }

  // Рекурсивный вызов в Parens, поэтому нужен тип
  def Expression: Rule0 = rule { Term ~ zeroOrMore('+' ~ Term | '-' ~ Term) }

  def Term   = rule { Factor ~ zeroOrMore('*' ~ Factor | '/' ~ Factor) }

  def Factor = rule { Number | Parens }

  def Parens = rule { '(' ~ Expression ~ ')' }

  def Number = rule { oneOrMore(CharPredicate.Digit) }
}
					</code></pre>
				</section>

				<section>
					<h2>арифметическое выражение:<br/> да или нет?</h2>
					<pre><code data-trim class="scala">
val line = readline()
val calc = new CalculatorParser(line)

calc.InputLine().run() match {
  case Success(_) => "Yes" 
  case Failure(_) => "No"
}
					</code></pre>
				</section>

				<section>
					<h2>parser actions, value-stack</h2>

					<p>value-stack — отличие от haskell parsec et al.</p>

					<pre><code data-trim class="scala">
class ValueStack(initialSize: Int, maxSize: Int) extends Iterable[Any] {
  var buffer = new Array[Any](initialSize)
  var size   = 0
}
					</code></pre>

					<pre><code data-trim class="scala">
def Digits    = rule { oneOrMore("0" | "1" | /*...*/ "9") } // oneOrMore("0"-"9")

def False     = rule { "false" ~ push(false) } // "false" >>> VStk: [false]

def NumberStr = rule { capture(Digits) } // "42" >>> VStk: ["42"]

def Number    = rule { capture(Digits) ~> (_.toInt) } "42" >>> // VStk: [42]

def Sum       = rule { Number ~ " " ~ Number ~> ((_:Int) + _) } // "11 15" >>> VStk: [26]
					</code></pre>
				</section>

				<section>
				<h2>калькулятор</h2>
					<pre><code data-trim class="scala">
class CalculatorParser(val input: ParserInput) extends Parser {
  def Expression: Rule1[Int] = rule {
    Term ~ zeroOrMore(
      '+' ~ Term ~> ((_: Int) + _)
    | '-' ~ Term ~> ((_: Int) - _))
  }

  def Term = rule {
    Factor ~ zeroOrMore(
      '*' ~ Factor ~> ((_: Int) * _)
    | '/' ~ Factor ~> ((_: Int) / _))
  }
}
					</code></pre>

					<p>`~>` может передавать элемент AST в стек</p>
					<p>`~>`-обработчик сам может быть парсером</p>
				</section>

				<section>
					<h2>типизация правил и value-stack</h2>
					<pre style="width: 80%"><code data-trim class="scala">
def InputRule: Rule[HNil, String :: HNil] = rule { capture("a") }

class Rule[-I <: HList, +O <: HList]
I - тип значения со стека
O - тип значения в стек
					</code></pre>

					<pre style="width: 80%"><code data-trim class="scala">
type RuleN[L <: HList] = Rule[HNil, L]
type Rule0 = RuleN[HNil]
type Rule1[T] = RuleN[T :: HNil]
type Rule2[A, B] = RuleN[A :: B :: HNil]
					</code></pre>
				</section>

				<section>
					<h2>типизация правил и value-stack</h2>
					<pre style="width: 105%"><code data-trim class="scala">
def a:  Rule1[String] = rule { capture("a") }

def b:  Rule1[String] = rule { capture("7") }

def bi: Rule1[Int]    = rule { b ~> ((_:String).toInt) } 
					</code></pre>
				</section>

				<section>
					<h2>типизация правил и value-stack</h2>
					<pre style="width: 105%"><code data-trim class="scala">
def c1: Rule2[String, Int] = rule { a ~ bi }

def c2: Rule2[Int, Int] = rule { bi ~ push(42) }

def c3: Rule[Int :: HNil, Int :: HNil] = rule { capture("7") ~> ((x: Int, y: String) => x + y.toInt) }
					</code></pre>
				</section>

				<section>
					<h2>компиляция</h2>
					<pre><code data-trim class="scala">
abstract class Parser {
  def rule(r: Rule): Rule = macro Parser.ruleImpl
}

object Parser {	
  def ruleImpl(ctx: ParserContext)(r: ctx.Expr[Rule]): ctx.Expr[Rule] = 
    reify {
      OpTree(r.tree).render().splice
    }
} 
  					</code></pre>
  				</section>

  				<section>
					<h2>компиляция</h2>
					<pre><code data-trim class="scala">
object OpTree {
  def apply(tree: Tree): OpTree =
    r.tree match { // квазицитирования
      case q"$a.this.str($s)" => LiteralString(s)
      case q"$a.this.ch($ch)" => LiteralChar(ch)
      case q"$lhs.|($rhs)"    => FirstOf(OpTree(lhs), OpTree(rhs))
      case q"$lhs.~($rhs)"    => Sequence(OpTree(lhs), OpTree(rhs))
    }
}

abstract class OpTree {
  def render(): Expr[Rule]
}

case class Rule(val matched: Boolean)
					</code></pre>
				</section>

				<section>
					<h2>LiteralChar</h2>
					<pre><code data-trim class="scala">
implicit def ch(c: Char): Rule0
rule { ch('a') }
case q"$a.this.ch($ch)" => // $a = CalculatorParser, $ch = CharLiteral('a')
					</code></pre>

					<pre><code data-trim class="scala">
case class LiteralChar(charTree: Tree) extends OpTree {
  def render(): Expr[Rule] = reify {
    val char = c.Expr[Char](charTree).splice
    val p = c.prefix.splice // Current parser
    Rule(p.__nextChar() == char)
  }
}
					</code></pre>
				</section>

<!-- 				<section>
					<h2>char</h2>
					<pre><code data-trim class="scala">
reify {
  if ($ch == p.cursorChar()) {
    p.advance()
    Rule.MATCH
  } else Rule.MISMATCH
} 
					</code></pre>
				</section> -->

				<section>
					<h2>LiteralString</h2>

					<pre><code data-trim class="scala">
implicit def str(c: String): Rule0
rule { str("abc") }
case q"$a.this.str($s)" => // $a = CalculatorParser, $s = StringLiteral("abc")
					</code></pre>

					<pre><code data-trim class="scala">
case class LiteralString(s: Tree) extends OpTree {
  def render(): Expr[Rule] = c.Expr[Rule](q`
    val p = ${c.prefix} // Current parser
    var ix = 0
    while (ix < $s.length && $s.charAt(ix) == p.__nextChar()) {
      ix += 1
    }
    Rule(ix == $s.length)
`)
					</code></pre>
				</section>

				<section>
					<h2>FirstOf: a | b</h2>
					<pre><code data-trim class="scala">
// case q"$lhs.|($rhs)" => 

case class FirstOf(charTree: Tree) extends OpTree {
  def render(): Expr[Rule] = c.Expr[Rule](q` 
    val mark = p.__cursor
    if (${OpTree(lhs).render()}.matched) {
      Rule(true)
    } else {
      p.__cursor = mark
      ${OpTree(rhs).render()}
    }
  `)
}
					</code></pre>
				</section>

				<section>
					<h2>Sequence: a ~ b</h2>
					<pre><code data-trim class="scala">
// case q"$lhs.~($rhs)" => 

case class FirstOf(charTree: Tree) extends OpTree {
  def render(): Expr[Rule] = c.Expr[Rule](q`
    Rule(${OpTree(lhs).render()}.matched && ${OpTree(rhs).render()}.matched)
  `)
}
					</code></pre>
				</section>

				<section>
					<h2>parboiled2.org</h2>
					<ul>
						<li>oneOrMore</li>
						<li>zeroOrMore</li>
						<li>~></li>
						<li>...</li>
					</ul>
				</section>

				<section>
					<h2>использование</h2>
					<ul>
						<li>json-парсер в ~100 быстрее Scala Parsers, в ~10 parboiled1</li>
						<li>typesafe, spray.io, spray-json</li>
					</ul>
				</section>

				<section>
					<h3><a href="http://parboiled2.org">parboiled2.org</a></h3>
					<h4><a href="http://www.linkedin.com/in/alexandermyltsev">linkedin.com/in/alexandermyltsev</a></h4>
					<h4>вопросы</h4>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
