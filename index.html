<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<!-- <link rel="stylesheet" href="http://spray.io/wjax/css/theme/sirthias.css" id="theme"> -->
		<link rel="stylesheet" href="css/theme/my.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

        <style>
            .reveal pre {
                box-shadow: none; }

            .reveal pre code {
                background: none;
                font-size: 1.2em;
                line-height: 1.1em;
                max-height: 420px; }
        </style>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>parboiled2</h1>
					<h4>a macro-based PEG-parsers generator for Scala 2.10+</h4>
					<p>
						<small>
                            Alexander-Myltsev <br/>
                            <a href="https://github.com/alexander-myltsev">alexander-myltsev@github</a> <br/>
						    <a href="http://www.linkedin.com/in/alexandermyltsev">linkedin.com/in/alexandermyltsev</a> <br/>
                            <a href="http://twitter.com/alex_myltsev">alex_myltsev@twitter</a>
                        </small>
					</p>
				</section>

                <section>
                    <h2>credentials</h2>
                    <img style="width:100%" src="lib/contribute.png" alt="application">
                    <ul>
                        <li>a core contributor (Google SoC'13 mostly)</li>
                        <li>a core contributor to scala-js porting</li>
                    </ul>
                </section>

				<section>
					<h2>parsing task</h2>
					<ul>
						<li>input: stream of characters or bytes</li>
						<li>output: is it structured? what is the structure?</li>
					</ul>

					<br/><br/>

                    example:

					<pre><code data-trim class="scala">
1 + 2 * 3

1) is it arithmetical expression? — yes!

                                 +
                                / \
2) what is the structure? —    1   *
                                  / \
                                 2   3
                    </code></pre>

				</section>

                <section>
                    <h2>requirements</h2>
                    <ol>
                        <li>work inside of Scala ecosystem
                            <ul>
                                <li>Java — not necessary</li>
                                <li>IDE support</li>
                            </ul>
                        </li>
                        <li>work fast</li>
                        <li>easy to maintain — typed embedded DSL</li>
                        <li>have few dependencies</li>
                    </ol>
                </section>

                <section>
                    <h2>RegEx</h2>

                    <p>can't parse recursive data like</p>
                    <ol>
                        <li>arithmetical expression</li>
                        <li>json</li>
                        <li>...</li>
                    </ol>
                </section>

                <section>
                    <h2>alternatives (some of...)</h2>
                    <ul>
                        <li>barehanded parser
                            <ul>
                                <li><a href="https://github.com/akheron/jansson/blob/master/src/load.c">github.com/akheron/jansson/blob/master/src/load.c</a></li>
                                <li><a href="https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js">github.com/douglascrockford/JSON-js/blob/master/json_parse.js</a></li>
                            </ul>
                        </li>
                        <li>Antlr — ANother Tool for Language Recognition</li>
                        <li>parser combinators (Haskell Parsec, Scala parser combinators, etc.)</li>
                    </ul>

                    <br/><br/>

                    <h4>either different IDE, or slower, or harder to maintain</h4>
                </section>

                <section>
                    <h2>parboiled 1.x</h2>
                    <ul>
                        <li>~10 times slower</li>
                        <li>not very powerful DSL</li>
                        <li>more dependencies</li>
                    </ul>
                </section>

				<section>
					<h1>parboiled2</h1>
				</section>


                <section>
                    <h2>core features</h2>
                    <ul>
                        <li>based on PEG — Parsing Expression Grammar</li>
                        <li>flexible and type-safe DSL</li>
                        <li>compiled rules and performance</li>
                        <li>one parsing phase, no lexer required</li>
                    </ul>
                </section>

                <section>
                    <h2>install it</h2>
                    <ul>
                        <li>just a Scala lib</li>
                        <li>2.10.4 and 2.11.1</li>
                    </ul>

                    <pre style="width: 85%"><code data-trim class="scala">
libraryDependencies += "org.parboiled" %% "parboiled" % "2.0.0"
                    </code></pre>
                </section>

                <section>
                    <h2>toy parser</h2>
<pre><code data-trim class="scala">
abstract class Parser {
  def input: ParserInput
}

class ToyParser(val input: ParserInput) extends Parser {
  def InputLine = rule { "a" ~ ("b" | "c") }
}
</code></pre>
                </section>

                <section>
                    <h2>toy parser</h2>
<pre><code data-trim class="scala">
def InputLine = rule { "a" ~ ("b" | "c") }
</code></pre>

<pre class="fragment"><code data-trim class="scala">
> new ToyParser("ab").InputLine.run()
Try[Unit] = Success(())
</code></pre>

<pre class="fragment"><code data-trim class="scala">
> new ToyParser("ac").InputLine.run()
Try[Unit] = Success(())
</code></pre>

<pre class="fragment"><code data-trim class="scala">
> new ToyParser("d").InputLine.run()
Try[Unit] = Failure(org.parboiled2.ParseError)
</code></pre>
                </section>

                <section>
                    <h2>toy parser: step by step</h2>
                    <pre><code data-trim class="scala">
def InputLine = rule { "a" ~ ("b" | "c") }

input: "ac"
                    </code></pre>

                    <ol>
                        <li class="fragment">InputLine starts — calls "~" subrule — cursor is at 0 pos</li>
                        <li class="fragment">"~" matches left subrule "a", and if succeeds then right subrule "|"</li>
                        <li class="fragment">rule "a" is matched against input(0) — cursor is at 1</li>
                        <li class="fragment">"|" matches left subrule "b", and if fails then matches subrule "c"</li>
                        <li class="fragment">"b" is failed to match — cursor stays at 1</li>
                        <li class="fragment">"c" is succeeded to match — cursor stays at 2</li>
                        <li class="fragment">match is successful</li>
                    </ol>
                </section>

                <section>
                    <h2>value stack & typed rules</h2>
                </section>

                <section>
                    <h2>value stack</h2>
                    <ol>
                        <li>rules <u>do not</u> return any value</li>
                        <li>push and pop result from <em>ValueStack</em>
                            <ul>
                                <li>implicit temporary storage</li>
                                <li>e.g. used for constructing AST, "in-phase" computations</li>
                            </ul>
                        </li>
                        <li>rule is typed according to its interaction with <em>ValueStack</em></li>
                    </ol>
                </section>

                <section>
                    <h2>rule types</h2>
                    <pre><code data-trim class="scala">
class Rule[-I <: HList, +O <: HList]
                    </code></pre>

                    <ul>
                        <li><b>I &nbsp; <&colon; HList</b> &nbsp; encodes number and types the rule <u>pops off</u></li>
                        <li><b>O <&colon; HList</b> &nbsp; encodes number and types the rule <u>pushes on</u></li>
                        <li>types are inferred (in most cases)</li>
                        <li>RuleN[A :: B :: HNil] — B is pushed <u>after</u> A</li>
                        <li>aliases</li>
                    </ul>

<pre><code data-trim class="scala">
type Rule0               = RuleN[HNil]
type Rule1[T]            = RuleN[T :: HNil]
type Rule2[A, B]         = RuleN[A :: B :: HNil]
type RuleN[L <: HList]   = Rule[HNil, L]
type PopRule[L <: HList] = Rule[L, HNil]
</code></pre>
                </section>

                <section>
                    <h2>rules groups</h2>
                    <ul>
                        <li>basic chars matchers</li>
                        <li>rules combinators and modifiers</li>
                        <li>parser actions</li>
                    </ul>
                </section>

                <section>
                    <h2>basic chars matchers</h2>
                    <ul>
                        <li>match input and cause progress</li>
                        <li>do nothing with <em>ValueStack</em></li>
                    </ul>


                    <pre class="fragment"><code data-trim class="scala">
implicit def ch(c: Char): Rule0
rule { 'a' } ~> rule { ch('a') }
                    </code></pre>

                    <pre class="fragment"><code data-trim class="scala">
implicit def str(s: String): Rule0
rule { "a" } ~> rule { str("a") }

rule { 42 } // compile-time error
                    </code></pre>

                    <pre class="fragment"><code data-trim class="scala">
implicit def predicate(p: CharPredicate): Rule0
CharPredicate.Digit, CharPredicate.LowerHexLetter, etc.
                    </code></pre>

                    <pre class="fragment"><code data-trim class="scala">
def anyOf(chars: String): Rule0
def noneOf(chars: String): Rule0

def ignoreCase(c: Char): Rule0
def ignoreCase(s: String): Rule0
                    </code></pre>

                    <pre class="fragment"><code data-trim class="scala">
def ANY: Rule0
def EOI: Char
def MATCH: Rule0
def MISMATCH[I <: HList, O <: HList]: Rule[I, O]
def MISMATCH0: Rule0
                    </code></pre>
                </section>

                <section>
                    <h3>rules combinators & modifiers: a ~ b</h3>
                    <ul>
                        <li>matches if <em>a</em> matches and then if <em>b</em> matches</li>
                        <li>type</li>
                    </ul>

                    <pre><code data-trim class="scala">
def a: Rule[Int] = // ...
def b: Rule[String] = // ...
def c: RuleN[Int :: String :: HNil] = rule { a ~ b }
                    </code></pre>
<pre class="fragment"><code data-trim class="scala">
Rule[     , A    ] ~ Rule[     , B  ] = Rule[     , A:B    ]
</code></pre>

<pre class="fragment"><code data-trim class="scala">
Rule[A:B:C, D:E:F] ~ Rule[F    , G:H] = Rule[A:B:C, D:E:G:H]
</code></pre>

<pre class="fragment"><code data-trim class="scala">
Rule[A    , B:C  ] ~ Rule[D:B:C, E:F] = Rule[D:A  , E:F]
</code></pre>

<pre class="fragment"><code data-trim class="scala">
Rule[A    , B:C  ] ~ Rule[D:C  , E:F] - is Illegal if D != B
</code></pre>
                </section>

                <section>
                    <h3>rules combinators & modifiers</h3>
<pre style="width: 55%"><code data-trim class="scala">
a | b
</code></pre>

<pre style="width: 55%" class="fragment"><code data-trim class="scala">
!(a)
&(a) = !(!(a))
</code></pre>

<pre style="width: 55%" class="fragment"><code data-trim class="scala">
optional(a) = a | MATCH
</code></pre>

<pre style="width: 55%" class="fragment"><code data-trim class="scala">
zeroOrMore(a)
oneOrMore(a) = a ~ zeroOrMore(a)
</code></pre>

<pre style="width: 55%" class="fragment"><code data-trim class="scala">
(count: Int).times(a)
(10 to 15).times(a)
</code></pre>

<pre style="width: 55%" class="fragment"><code data-trim class="scala">
a.separatedBy(separator: Rule0)
</code></pre>
                </section>

                <section>
                    <h2>parser actions</h2>
                    <ul>
                        <li>can build recognizers so far: "does it have structure or not?"</li>
                        <li>need "actions" to produce result</li>
                    </ul>
                </section>

                <section>
                    <h2>push</h2>

					<p>pushes value onto <em>ValueStack</em></p>

					<pre><code data-trim class="scala">
rule { "true" ~ push(true) }
					</code></pre>

                    <pre class="fragment"><code data-trim class="scala">
push(e: Unit)       : Rule0    - pushes nothing
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
push(e: L <: HList) : RuleN[L] - pushes all values of L
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
push(e: T)          : Rule1[T] - pushes a value of T
					</code></pre>
                </section>

                <section>
                    <h2>capture</h2>

                    <p>pushes additional matched string onto <em>ValueStack</em></p>

					<pre><code data-trim class="scala">
rule { capture("42") } - if input matches "42" then pushes "42"
					</code></pre>

                    <pre class="fragment"><code data-trim class="scala">
capture(zeroOrMore(CharPredicate.Digit)) : Rule1[String]
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
caputure("true" ~ push(true))            : Rule2[Boolean, String]
					</code></pre>
                </section>

				<section>
                    <h2>a ~> (func)</h2>
                	<p>transforms top elements of the <em>Value Stack</em> into some other object(s)</p>

                	<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[String])      ~> ((s: String) ⇒ s.toInt)  : Rule1[Int]
					</code></pre>

                	<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[String])      ~> (s ⇒ s.toInt)            : Rule1[Int]
					</code></pre>

                	<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[Int, String]) ~> ((i, s) ⇒ i + s.toInt)   : Rule1[String]
					</code></pre>

                	<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[String])      ~> (_.toInt)                : Rule1[String]
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[String])      ~> (println(_))             : Rule0
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[String])      ~> (() ⇒ 17)                : Rule2[String, Int]
(foo: Rule1[String])      ~  push(17)                 : Rule2[String, Int]
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[String]) ~> (s ⇒ s.toInt :: 3.14 :: HNil) : Rule2[String, Int]
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
case class Person(name: String, age: Int)

(foo: Rule2[String, Int]) ~> Person                   : Rule1[Person]
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
(foo: Rule1[Int]) ~> (i => test(i % 2 == 0) ~ push(i)): Rule1[Int]
					</code></pre>
                </section>

                <section>
                    <h2>reduction rules</h2>
                    <p>parser makes progress leaving <em>value stack</em> unchanged</p>

                    <pre class="fragment"><code data-trim class="scala">
capture(CharPredicate.Digit) ~ optional("h" ~> ((s: String) => s + "hex"))
                    </code></pre>

					<pre class="fragment"><code data-trim class="scala">
(factor: Rule1[Int]) ~ zeroOrMore("*" ~ factor ~> ((a: Int, b) => a * b))
					</code></pre>

					<pre class="fragment"><code data-trim class="scala">
(factor: Rule1[Int]) ~ oneOrMore("*" ~ factor ~> ((a: Int, b) => a * b))
					</code></pre>
                </section>

                <section>
                	<h2>calculator</h2>

<pre><code data-trim class="scala">
> new Calculator("1+2*3").InputLine.run() 
scala.util.Success(7)
</code></pre>

<pre class="fragment"><code data-trim class="scala">
class Calculator(val input: ParserInput) extends Parser {
</code></pre>

<pre class="fragment"><code data-trim class="scala">
def Digits = rule { oneOrMore(CharPredicate.Digit) } // Rule1[Stirng]

def Number = rule { capture(Digits) ~> (_.toInt) }   // Rule1[Int]
</code></pre>

<pre class="fragment"><code data-trim class="scala">
def Parens = rule { '(' ~ Expression ~ ')' }
</code></pre>

<pre class="fragment"><code data-trim class="scala">
def Factor = rule { Number | Parens }
</code></pre>

<pre class="fragment"><code data-trim class="scala">
def Term = rule {
  Factor ~ zeroOrMore(
    '*' ~ Factor ~> ((_: Int) * _)
  | '/' ~ Factor ~> ((_: Int) / _))
}
</code></pre>

<pre class="fragment"><code data-trim class="scala">
def Expression: Rule1[Int] = rule {
  Term ~ zeroOrMore(
    '+' ~ Term ~> ((_: Int) + _)
  | '-' ~ Term ~> ((_: Int) - _))
}
</code></pre>

<pre class="fragment"><code data-trim class="scala">
  def InputLine = rule { Expression ~ EOI }

}
</code></pre>
                </section>

                <section>
                	<h2>under the hood</h2>
                </section>

				<section>
					<h2>rule macro</h2>
					<pre><code data-trim class="scala">
case class Rule(matched: Boolean)
</code></pre>

<pre class="fragment"><code data-trim class="scala">
abstract class Parser {
  def rule(r: Rule): Rule = macro ParserMacros.ruleImpl

  def input: ParserInput
  def __nextChar(): Char = // ...
  def __cursor: Int = // ...
}
</code></pre>

<pre class="fragment"><code data-trim class="scala">
object ParserMacros {	
  def ruleImpl(ctx: ParserContext)(r: ctx.Expr[Rule]): ctx.Expr[Rule] = 
    reify {
      OpTree(r.tree).render().splice
    }
} 
  					</code></pre>
  				</section>

  				<section>
  					<h2>two step render()</h2>
  					<ol>
  						<li>in: Scala compiler AST</li>
  						<li>IR:  parboiled2 OpTree</li>
  						<li>out: effective Scala code AST</li>
  					</ol>
  				</section>

  				<section>
  					<h2>quasiquotes match</h2>

  					<pre><code data-trim class="scala">
def r = rule { "a" }
def r = rule { str("a") }
def r = rule { CurrentParser.this.str("a") }
  					</code></pre>

  					<pre class="fragment"><code data-trim class="scala">
r.tree = Apply(Select(This(TypeName("CurrentParser")), TermName("str")),
               List(Literal(Constant("777"))))
  					</code></pre>

  					<pre class="fragment"><code data-trim class="scala">
r.tree match {
  case Apply(Select(_, TermName("str")), List(Literal(Constant(s)))) =>
    StringMatch(s) // s is "a"
}
  					</code></pre>

  					<pre class="fragment"><code data-trim class="scala">
r.tree match {
  case q"$a.this.str($s)" => StringMatch(s) // a is CurrentParser
                                            // s is "a"
}
  					</code></pre>
  				</section>

  				<section>
  					<h2>OpTree</h2>
<pre><code data-trim class="scala">
object OpTree {
  def apply(tree: Tree): OpTree =
    r.tree match {
      case q"$a.this.str($s)" ⇒ StringMatch(s)
      case q"$a.this.ch($ch)" ⇒ CharMatch(ch)
      case q"$lhs.|($rhs)"    ⇒ FirstOf(OpTree(lhs), OpTree(rhs))
      case q"$lhs.~($rhs)"    ⇒ Sequence(OpTree(lhs), OpTree(rhs))
    }
}
</code></pre>

<pre class="fragment"><code data-trim class="scala">
abstract class OpTree {
  def render(): Expr[Rule]
}
class StringMatch(s: Tree)               extends OpTree
class CharMatch(ch: Tree)                extends OpTree
class FirstOf(lhs: OpTree, rhs: OpTree)  extends OpTree
class Sequence(lhs: OpTree, rhs: OpTree) extends OpTree
</code></pre>
  				</section>

				<section>
					<h2>CharMatch</h2>
					<pre><code data-trim class="scala">
case class CharMatch(charTree: Tree) extends OpTree {
  def render(): Expr[Rule] = reify {
    val char = c.Expr[Char](charTree).splice
    val p    = c.prefix.splice // Current parser
    Rule(p.__nextChar() == char)
  }
}
					</code></pre>
				</section>

				<section>
					<h2>StringMatch</h2>

					<pre><code data-trim class="scala">
case class StringMatch(strTree: Tree) extends OpTree {
  def render(): Expr[Rule] = c.Expr[Rule](q''
    val p   = ${c.prefix} // Current parser
    val str = $strTree    // : String

    // Naive
    val matched = str.forall(c => c == p.__nextChar())
    Rule(matched)

    // Effective
    var ix = 0
    while (ix < str.length && str.charAt(ix) == p.__nextChar()) {
      ix += 1
    }
    Rule(ix == $s.length)
'')
					</code></pre>
				</section>

				<section>
					<h2>FirstOf: a | b</h2>
					<pre><code data-trim class="scala">
// case q"$lhs.|($rhs)" => FirstOf(OpTree(lhs), OpTree(rhs))

case class FirstOf(lhs: OpTree, rhs: OpTree) extends OpTree {
  def render(): Expr[Rule] = c.Expr[Rule](q''
    val mark = p.__cursor
    if (lhs.render().matched) {
      Rule(true)
    } else {
      p.__cursor = mark
      val res = rhs.render().matched
      Rule(res)
    }
  '')
}
					</code></pre>
				</section>

				<section>
					<h2>Sequence: a ~ b</h2>
					<pre><code data-trim class="scala">
// case q"$lhs.~($rhs)" => 

case class Sequence(lhs: OpTree, rhs: OpTree) extends OpTree {
  def render(): Expr[Rule] = c.Expr[Rule](q''
    val res = lhs.render().matched && rhs.render().matched
    Rule(res)
  '')
}
					</code></pre>
				</section>

                <section>
                	<h2>benchmark</h2>
                	<pre><code data-trim class="scala">
> cappi::benchmark

            benchmark    ms linear runtime
        Json4SJackson  4.09 =
 Parboiled1JsonParser 85.64 ==============================
             Argonaut  7.01 ==
         Json4SNative  8.06 ==
 Parboiled2JsonParser 13.17 ====
                	</code></pre>
                </section>

                <section>
                    <h3>Thanks</h3>
                    <ul>
                        <li>Mathias Doenitz (<a href="https://github.com/sirthias/">sirthias@github</a>) for great mentoring</li>
                        <li>Eugene Burmako (<a href="https://github.com/xeno-by/">xeno-by@github</a>) et al. for Macro Paradise</li>
                        <li>Scala community</li>
                    </ul>
				</section>

                <section>
                    <h2>Q &amp; A</h2>
                    <h4>@Alex_Myltsev</h4>
                    <h3><a href="http://parboiled2.org">parboiled2.org</a></h3>
                </section>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				],

                transition: 'none',
                transitionSpeed: 'fast',
                backgroundTransition: 'slide'
			});

		</script>

	</body>
</html>
